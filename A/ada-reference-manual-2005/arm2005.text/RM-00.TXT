

            Foreword to this version of the Ada Reference Manual


0.1/1 The International Standard for the programming language Ada is ISO/IEC
8652:1995(E).

0.2/1 The Ada Working Group ISO/IEC JTC 1/SC 22/WG 9 is tasked by ISO with the
work item to interpret and maintain the International Standard and to produce
Technical Corrigenda, as appropriate. The technical work on the International
Standard is performed by the Ada Rapporteur Group (ARG) of WG 9. In September
2000, WG 9 approved and forwarded Technical Corrigendum 1 to SC 22 for ISO
approval, which was granted in February 2001. Technical Corrigendum 1 was
published in June 2001.

0.3/2 In October 2002, WG 9 approved a schedule and guidelines for the
preparation of an Amendment to the International Standard. WG 9 approved the
scope of the Amendment in June 2004. In April 2006, WG 9 approved and
forwarded the Amendment to SC 22 for approval, which was granted in August
2006. Final ISO/IEC approval is expected by early 2007.

0.4/1 The Technical Corrigendum lists the individual changes that need to be
made to the text of the International Standard to correct errors, omissions or
inconsistencies. The corrections specified in Technical Corrigendum 1 are part
of the International Standard ISO/IEC 8652:1995(E).

0.5/2 Similarly, Amendment 1 lists the individual changes that need to be made
to the text of the International Standard to add new features as well as
correct errors.

0.6/2 When ISO published Technical Corrigendum 1, it did not also publish a
document that merges the changes from the Technical Corrigendum into the text
of the International Standard. It is not known whether ISO will publish a
document that merges the changes from Technical Corrigendum and Amendment 1
into the text of the International Standard. However, ISO rules require that
the project editor for the International Standard be able to produce such a
document on demand.

0.7/2 This version of the Ada Reference Manual is what the project editor
would provide to ISO in response to such a request. It incorporates the
changes specified in the Technical Corrigendum and Amendment into the text of
ISO/IEC 8652:1995(E). It should be understood that the publication of any ISO
document involves changes in general format, boilerplate, headers, etc., as
well as a review by professional editors that may introduce editorial changes
to the text. This version of the Ada Reference Manual is therefore neither an
official ISO document, nor a version guaranteed to be identical to an official
ISO document, should ISO decide to reprint the International Standard
incorporating an approved Technical Corrigendum and Amendment. It is
nevertheless a best effort to be as close as possible to the technical content
of such an updated document. In the case of a conflict between this document
and Amendment 1 as approved by ISO (or between this document and Technical
Corrigendum 1 in the case of paragraphs not changed by Amendment 1; or between
this document and the original 8652:1995 in the case of paragraphs not changed
by either Amendment 1 or Technical Corrigendum 1), the other documents contain
the official text of the International Standard ISO/IEC 8652:1995(E) and its
Amendment.

0.8/2 As it is very inconvenient to have the Reference Manual for Ada
specified in three documents, this consolidated version of the Ada Reference
Manual is made available to the public.


                                  Foreword


1   ISO (the International Organization for Standardization) and IEC (the
International Electrotechnical Commission) form the specialized system for
worldwide standardization. National bodies that are members of ISO or IEC
participate in the development of International Standards through technical
committees established by the respective organization to deal with particular
fields of technical activity. ISO and IEC technical committees collaborate in
fields of mutual interest. Other international organizations, governmental and
non-governmental, in liaison with ISO and IEC, also take part in the work.

2   In the field of information technology, ISO and IEC have established a
joint technical committee, ISO/IEC JTC 1. Draft International Standards
adopted by the joint technical committee are circulated to national bodies for
voting. Publication as an International Standard requires approval by at least
75 % of the national bodies casting a vote.

3   International Standard ISO/IEC 8652 was prepared by Joint Technical
Committee ISO/IEC JTC 1, Information Technology.

4/2 This consolidated edition updates the second edition (ISO 8652:1995).

5/2 Annexes A to J form an integral part of this International Standard.
Annexes K to Q are for information only.


                                Introduction


1   This is the Ada Reference Manual.

2   Other available Ada documents include:

3/2   * Ada 95 Rationale. This gives an introduction to the new features of
        Ada incorporated in the 1995 edition of this Standard, and explains
        the rationale behind them. Programmers unfamiliar with Ada 95 should
        read this first.

3.1/2   * Ada 2005 Rationale. This gives an introduction to the changes and
        new features in Ada 2005 (compared with the 1995 edition), and
        explains the rationale behind them. Programmers should read this
        rationale before reading this Standard in depth.

4/1   * This paragraph was deleted.

5/2   * The Annotated Ada Reference Manual (AARM). The AARM contains all of
        the text in the consolidated Ada Reference Manual, plus various
        annotations. It is intended primarily for compiler writers, validation
        test writers, and others who wish to study the fine details. The
        annotations include detailed rationale for individual rules and
        explanations of some of the more arcane interactions among the rules.

Design Goals

6/2 Ada was originally designed with three overriding concerns: program
reliability and maintenance, programming as a human activity, and efficiency.
The 1995 revision to the language was designed to provide greater flexibility
and extensibility, additional control over storage management and
synchronization, and standardized packages oriented toward supporting
important application areas, while at the same time retaining the original
emphasis on reliability, maintainability, and efficiency. This amended version
provides further flexibility and adds more standardized packages within the
framework provided by the 1995 revision.

7   The need for languages that promote reliability and simplify maintenance
is well established. Hence emphasis was placed on program readability over
ease of writing. For example, the rules of the language require that program
variables be explicitly declared and that their type be specified. Since the
type of a variable is invariant, compilers can ensure that operations on
variables are compatible with the properties intended for objects of the type.
Furthermore, error-prone notations have been avoided, and the syntax of the
language avoids the use of encoded forms in favor of more English-like
constructs. Finally, the language offers support for separate compilation of
program units in a way that facilitates program development and maintenance,
and which provides the same degree of checking between units as within a unit.

8   Concern for the human programmer was also stressed during the design.
Above all, an attempt was made to keep to a relatively small number of
underlying concepts integrated in a consistent and systematic way while
continuing to avoid the pitfalls of excessive involution. The design
especially aims to provide language constructs that correspond intuitively to
the normal expectations of users.

9   Like many other human activities, the development of programs is becoming
ever more decentralized and distributed. Consequently, the ability to assemble
a program from independently produced software components continues to be a
central idea in the design. The concepts of packages, of private types, and of
generic units are directly related to this idea, which has ramifications in
many other aspects of the language. An allied concern is the maintenance of
programs to match changing requirements; type extension and the hierarchical
library enable a program to be modified while minimizing disturbance to
existing tested and trusted components.

10  No language can avoid the problem of efficiency. Languages that require
over-elaborate compilers, or that lead to the inefficient use of storage or
execution time, force these inefficiencies on all machines and on all
programs. Every construct of the language was examined in the light of present
implementation techniques. Any proposed construct whose implementation was
unclear or that required excessive machine resources was rejected.

Language Summary

11  An Ada program is composed of one or more program units. Program units may
be subprograms (which define executable algorithms), packages (which define
collections of entities), task units (which define concurrent computations),
protected units (which define operations for the coordinated sharing of data
between tasks), or generic units (which define parameterized forms of packages
and subprograms). Each program unit normally consists of two parts: a
specification, containing the information that must be visible to other units,
and a body, containing the implementation details, which need not be visible
to other units. Most program units can be compiled separately.

12  This distinction of the specification and body, and the ability to compile
units separately, allows a program to be designed, written, and tested as a
set of largely independent software components.

13  An Ada program will normally make use of a library of program units of
general utility. The language provides means whereby individual organizations
can construct their own libraries. All libraries are structured in a
hierarchical manner; this enables the logical decomposition of a subsystem
into individual components. The text of a separately compiled program unit
must name the library units it requires.

14  Program Units

15  A subprogram is the basic unit for expressing an algorithm. There are two
kinds of subprograms: procedures and functions. A procedure is the means of
invoking a series of actions. For example, it may read data, update variables,
or produce some output. It may have parameters, to provide a controlled means
of passing information between the procedure and the point of call. A function
is the means of invoking the computation of a value. It is similar to a
procedure, but in addition will return a result.

16  A package is the basic unit for defining a collection of logically related
entities. For example, a package can be used to define a set of type
declarations and associated operations. Portions of a package can be hidden
from the user, thus allowing access only to the logical properties expressed
by the package specification.

17  Subprogram and package units may be compiled separately and arranged in
hierarchies of parent and child units giving fine control over visibility of
the logical properties and their detailed implementation.

18  A task unit is the basic unit for defining a task whose sequence of
actions may be executed concurrently with those of other tasks. Such tasks may
be implemented on multicomputers, multiprocessors, or with interleaved
execution on a single processor. A task unit may define either a single
executing task or a task type permitting the creation of any number of similar
tasks.

19/2 A protected unit is the basic unit for defining protected operations for
the coordinated use of data shared between tasks. Simple mutual exclusion is
provided automatically, and more elaborate sharing protocols can be defined. A
protected operation can either be a subprogram or an entry. A protected entry
specifies a Boolean expression (an entry barrier) that must be True before the
body of the entry is executed. A protected unit may define a single protected
object or a protected type permitting the creation of several similar objects.

20  Declarations and Statements

21  The body of a program unit generally contains two parts: a declarative
part, which defines the logical entities to be used in the program unit, and a
sequence of statements, which defines the execution of the program unit.

22  The declarative part associates names with declared entities. For example,
a name may denote a type, a constant, a variable, or an exception. A
declarative part also introduces the names and parameters of other nested
subprograms, packages, task units, protected units, and generic units to be
used in the program unit.

23  The sequence of statements describes a sequence of actions that are to be
performed. The statements are executed in succession (unless a transfer of
control causes execution to continue from another place).

24  An assignment statement changes the value of a variable. A procedure call
invokes execution of a procedure after associating any actual parameters
provided at the call with the corresponding formal parameters.

25  Case statements and if statements allow the selection of an enclosed
sequence of statements based on the value of an expression or on the value of
a condition.

26  The loop statement provides the basic iterative mechanism in the language.
A loop statement specifies that a sequence of statements is to be executed
repeatedly as directed by an iteration scheme, or until an exit statement is
encountered.

27  A block statement comprises a sequence of statements preceded by the
declaration of local entities used by the statements.

28  Certain statements are associated with concurrent execution. A delay
statement delays the execution of a task for a specified duration or until a
specified time. An entry call statement is written as a procedure call
statement; it requests an operation on a task or on a protected object,
blocking the caller until the operation can be performed. A called task may
accept an entry call by executing a corresponding accept statement, which
specifies the actions then to be performed as part of the rendezvous with the
calling task. An entry call on a protected object is processed when the
corresponding entry barrier evaluates to true, whereupon the body of the entry
is executed. The requeue statement permits the provision of a service as a
number of related activities with preference control. One form of the select
statement allows a selective wait for one of several alternative rendezvous.
Other forms of the select statement allow conditional or timed entry calls and
the asynchronous transfer of control in response to some triggering event.

29  Execution of a program unit may encounter error situations in which normal
program execution cannot continue. For example, an arithmetic computation may
exceed the maximum allowed value of a number, or an attempt may be made to
access an array component by using an incorrect index value. To deal with such
error situations, the statements of a program unit can be textually followed
by exception handlers that specify the actions to be taken when the error
situation arises. Exceptions can be raised explicitly by a raise statement.

30  Data Types

31  Every object in the language has a type, which characterizes a set of
values and a set of applicable operations. The main classes of types are
elementary types (comprising enumeration, numeric, and access types) and
composite types (including array and record types).

32/2 An enumeration type defines an ordered set of distinct enumeration
literals, for example a list of states or an alphabet of characters. The
enumeration types Boolean, Character, Wide_Character, and Wide_Wide_Character
are predefined.

33  Numeric types provide a means of performing exact or approximate numerical
computations. Exact computations use integer types, which denote sets of
consecutive integers. Approximate computations use either fixed point types,
with absolute bounds on the error, or floating point types, with relative
bounds on the error. The numeric types Integer, Float, and Duration are
predefined.

34/2 Composite types allow definitions of structured objects with related
components. The composite types in the language include arrays and records. An
array is an object with indexed components of the same type. A record is an
object with named components of possibly different types. Task and protected
types are also forms of composite types. The array types String, Wide_String,
and Wide_Wide_String are predefined.

35  Record, task, and protected types may have special components called
discriminants which parameterize the type. Variant record structures that
depend on the values of discriminants can be defined within a record type.

36  Access types allow the construction of linked data structures. A value of
an access type represents a reference to an object declared as aliased or to
an object created by the evaluation of an allocator. Several variables of an
access type may designate the same object, and components of one object may
designate the same or other objects. Both the elements in such linked data
structures and their relation to other elements can be altered during program
execution. Access types also permit references to subprograms to be stored,
passed as parameters, and ultimately dereferenced as part of an indirect call.

37  Private types permit restricted views of a type. A private type can be
defined in a package so that only the logically necessary properties are made
visible to the users of the type. The full structural details that are
externally irrelevant are then only available within the package and any child
units.

38  From any type a new type may be defined by derivation. A type, together
with its derivatives (both direct and indirect) form a derivation class.
Class-wide operations may be defined that accept as a parameter an operand of
any type in a derivation class. For record and private types, the derivatives
may be extensions of the parent type. Types that support these object-oriented
capabilities of class-wide operations and type extension must be tagged, so
that the specific type of an operand within a derivation class can be
identified at run time. When an operation of a tagged type is applied to an
operand whose specific type is not known until run time, implicit dispatching
is performed based on the tag of the operand.

38.1/2 Interface types provide abstract models from which other interfaces and
types may be composed and derived. This provides a reliable form of multiple
inheritance. Interface types may also be implemented by task types and
protected types thereby enabling concurrent programming and inheritance to be
merged.

39  The concept of a type is further refined by the concept of a subtype,
whereby a user can constrain the set of allowed values of a type. Subtypes can
be used to define subranges of scalar types, arrays with a limited set of
index values, and records and private types with particular discriminant
values.

40  Other Facilities

41/2 Aspect clauses can be used to specify the mapping between types and
features of an underlying machine. For example, the user can specify that
objects of a given type must be represented with a given number of bits, or
that the components of a record are to be represented using a given storage
layout. Other features allow the controlled use of low level, nonportable, or
implementation-dependent aspects, including the direct insertion of machine
code.

42/2 The predefined environment of the language provides for input-output and
other capabilities by means of standard library packages. Input-output is
supported for values of user-defined as well as of predefined types. Standard
means of representing values in display form are also provided.

42.1/2 The predefined standard library packages provide facilities such as
string manipulation, containers of various kinds (vectors, lists, maps, etc.),
mathematical functions, random number generation, and access to the execution
environment.

42.2/2 The specialized annexes define further predefined library packages and
facilities with emphasis on areas such as real-time scheduling, interrupt
handling, distributed systems, numerical computation, and high-integrity
systems.

43  Finally, the language provides a powerful means of parameterization of
program units, called generic program units. The generic parameters can be
types and subprograms (as well as objects and packages) and so allow general
algorithms and data structures to be defined that are applicable to all types
of a given class.

Language Changes

44/2 This amended International Standard updates the edition of 1995 which
replaced the first edition of 1987. In the 1995 edition, the following major
language changes were incorporated:

45/2   * Support for standard 8-bit and 16-bit characters was added. See
        clauses 2.1, 3.5.2, 3.6.3, A.1, A.3, and A.4.

46/2   * The type model was extended to include facilities for object-oriented
        programming with dynamic polymorphism. See the discussions of classes,
        derived types, tagged types, record extensions, and private extensions
        in clauses 3.4, 3.9, and 7.3. Additional forms of generic formal
        parameters were allowed as described in clauses 12.5.1 and 12.7.

47/2   * Access types were extended to allow an access value to designate a
        subprogram or an object declared by an object declaration as opposed
        to just an object allocated on a heap. See clause 3.10.

48/2   * Efficient data-oriented synchronization was provided by the
        introduction of protected types. See clause 9.4.

49/2   * The library structure was extended to allow library units to be
        organized into a hierarchy of parent and child units. See clause
        10.1.

50/2   * Additional support was added for interfacing to other languages. See
        Annex B.

51/2   * The Specialized Needs Annexes were added to provide specific support
        for certain application areas:

52        * Annex C, "Systems Programming"

53        * Annex D, "Real-Time Systems"

54        * Annex E, "Distributed Systems"

55        * Annex F, "Information Systems"

56        * Annex G, "Numerics"

57        * Annex H, "High Integrity Systems"

57.1/2 Amendment 1 modifies the 1995 International Standard by making changes
and additions that improve the capability of the language and the reliability
of programs written in the language. In particular the changes were designed
to improve the portability of programs, interfacing to other languages, and
both the object-oriented and real-time capabilities.

57.2/2 The following significant changes with respect to the 1995 edition are
incorporated:

57.3/2   * Support for program text is extended to cover the entire ISO/IEC
        10646:2003 repertoire. Execution support now includes the 32-bit
        character set. See clauses 2.1, 3.5.2, 3.6.3, A.1, A.3, and A.4.

57.4/2   * The object-oriented model has been improved by the addition of an
        interface facility which provides multiple inheritance and additional
        flexibility for type extensions. See clauses 3.4, 3.9, and 7.3. An
        alternative notation for calling operations more akin to that used in
        other languages has also been added. See clause 4.1.3.

57.5/2   * Access types have been further extended to unify properties such as
        the ability to access constants and to exclude null values. See clause
        3.10. Anonymous access types are now permitted more freely and
        anonymous access-to-subprogram types are introduced. See clauses 3.3,
        3.6, 3.10, and 8.5.1.

57.6/2   * The control of structure and visibility has been enhanced to permit
        mutually dependent references between units and finer control over
        access from the private part of a package. See clauses 3.10.1 and
        10.1.2. In addition, limited types have been made more useful by the
        provision of aggregates, constants, and constructor functions. See
        clauses 4.3, 6.5, and 7.5.

57.7/2   * The predefined environment has been extended to include additional
        time and calendar operations, improved string handling, a
        comprehensive container library, file and directory management, and
        access to environment variables. See clauses 9.6.1, A.4, A.16, A.17,
        and A.18.

57.8/2   * Two of the Specialized Needs Annexes have been considerably
        enhanced:

57.9/2    * The Real-Time Systems Annex now includes the Ravenscar profile for
            high-integrity systems, further dispatching policies such as Round
            Robin and Earliest Deadline First, support for timing events, and
            support for control of CPU time utilization. See clauses D.2,
            D.13, D.14, and D.15.

57.10/2   * The Numerics Annex now includes support for real and complex
            vectors and matrices as previously defined in ISO/IEC 13813:1997
            plus further basic operations for linear algebra. See clause G.3.

57.11/2   * The overall reliability of the language has been enhanced by a
        number of improvements. These include new syntax which detects
        accidental overloading, as well as pragmas for making assertions and
        giving better control over the suppression of checks. See clauses
        6.1, 11.4.2, and 11.5.



Instructions for Comment Submission

58/1 Informal comments on this International Standard may be sent via e-mail
to ada-comment@ada-auth.org. If appropriate, the Project Editor will initiate
the defect correction procedure.

59  Comments should use the following format:

60/2         !topic Title summarizing comment
             !reference Ada 2005 RMss.ss(pp)
             !from Author Name yy-mm-dd
             !keywords keywords related to topic
             !discussion
        
             text of discussion

61  where ss.ss is the section, clause or subclause number, pp is the
paragraph number where applicable, and yy-mm-dd is the date the comment was
sent. The date is optional, as is the !keywords line.

62/1 Please use a descriptive "Subject" in your e-mail message, and limit each
message to a single comment.

63  When correcting typographical errors or making minor wording suggestions,
please put the correction directly as the topic of the comment; use square
brackets [ ] to indicate text to be omitted and curly braces { } to indicate
text to be added, and provide enough context to make the nature of the
suggestion self-evident or put additional information in the body of the
comment, for example:

64           !topic [c]{C}haracter
             !topic it[']s meaning is not defined

65  Formal requests for interpretations and for reporting defects in this
International Standard may be made in accordance with the ISO/IEC JTC 1
Directives and the ISO/IEC JTC 1/SC 22 policy for interpretations. National
Bodies may submit a Defect Report to ISO/IEC JTC 1/SC 22 for resolution under
the JTC 1 procedures. A response will be provided and, if appropriate, a
Technical Corrigendum will be issued in accordance with the procedures.



Acknowledgements for the Ada 95 edition of the Ada Reference Manual

66  This International Standard was prepared by the Ada 9X Mapping/Revision
Team based at Intermetrics, Inc., which has included: W. Carlson, Program
Manager; T. Taft, Technical Director; J. Barnes (consultant); B. Brosgol
(consultant); R. Duff (Oak Tree Software); M. Edwards; C. Garrity; R.
Hilliard; O. Pazy (consultant); D. Rosenfeld; L. Shafer; W. White; M. Woodger.

67  The following consultants to the Ada 9X Project contributed to the
Specialized Needs Annexes: T. Baker (Real-Time/Systems Programming - SEI,
FSU); K. Dritz (Numerics - Argonne National Laboratory); A. Gargaro
(Distributed Systems - Computer Sciences); J. Goodenough (Real-Time/Systems
Programming - SEI); J. McHugh (Secure Systems - consultant); B. Wichmann
(Safety-Critical Systems - NPL: UK).

68  This work was regularly reviewed by the Ada 9X Distinguished Reviewers and
the members of the Ada 9X Rapporteur Group (XRG): E. Ploedereder, Chairman of
DRs and XRG (University of Stuttgart: Germany); B. Bardin (Hughes); J. Barnes
(consultant: UK); B. Brett (DEC); B. Brosgol (consultant); R. Brukardt (RR
Software); N. Cohen (IBM); R. Dewar (NYU); G. Dismukes (TeleSoft); A. Evans
(consultant); A. Gargaro (Computer Sciences); M. Gerhardt (ESL); J. Goodenough
(SEI); S. Heilbrunner (University of Salzburg: Austria); P. Hilfinger
(UC/Berkeley); B. Källberg (CelsiusTech: Sweden); M. Kamrad II (Unisys); J.
van Katwijk (Delft University of Technology: The Netherlands); V. Kaufman
(Russia); P. Kruchten (Rational); R. Landwehr (CCI: Germany); C. Lester
(Portsmouth Polytechnic: UK); L. Månsson (TELIA Research: Sweden); S. Michell
(Multiprocessor Toolsmiths: Canada); M. Mills (US Air Force); D. Pogge (US
Navy); K. Power (Boeing); O. Roubine (Verdix: France); A. Strohmeier (Swiss
Fed Inst of Technology: Switzerland); W. Taylor (consultant: UK); J. Tokar
(Tartan); E. Vasilescu (Grumman); J. Vladik (Prospeks s.r.o.: Czech Republic);
S. Van Vlierberghe (OFFIS: Belgium).

69  Other valuable feedback influencing the revision process was provided by
the Ada 9X Language Precision Team (Odyssey Research Associates), the Ada 9X
User/Implementer Teams (AETECH, Tartan, TeleSoft), the Ada 9X Implementation
Analysis Team (New York University) and the Ada community-at-large.

70  Special thanks go to R. Mathis, Convenor of ISO/IEC JTC 1/SC 22 Working
Group 9.

71  The Ada 9X Project was sponsored by the Ada Joint Program Office.
Christine M. Anderson at the Air Force Phillips Laboratory (Kirtland AFB, NM)
was the project manager.

Acknowledgements for the Corrigendum version of the Ada Reference Manual

71.1/1 The editor [R. Brukardt (USA)] would like to thank the many people
whose hard work and assistance has made this revision possible.

71.2/1 Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording corrections
was critical to the entire process. Especially valuable contributions came
from the chairman of the ARG, E. Ploedereder (Germany), who kept the process
moving; J. Barnes (UK) and K. Ishihata (Japan), whose extremely detailed
reviews kept the editor on his toes; G. Dismukes (USA), M. Kamrad (USA), P.
Leroy (France), S. Michell (Canada), T. Taft (USA), J. Tokar (USA), and other
members too numerous to mention.

71.3/1 Special thanks go to R. Duff (USA) for his explanations of the previous
system of formatting of these documents during the tedious conversion to more
modern formats. Special thanks also go to the convener of ISO/IEC JTC 1/SC
22/WG 9, J. Moore (USA), without whose help and support the corrigendum and
this consolidated reference manual would not have been possible.

Acknowledgements for the Amendment version of the Ada Reference Manual

71.4/2 The editor [R. Brukardt (USA)] would like to thank the many people
whose hard work and assistance has made this revision possible.

71.5/2 Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording corrections
was critical to the entire process. Especially valuable contributions came
from the chairman of the ARG, P. Leroy (France), who kept the process on
schedule; J. Barnes (UK) whose careful reviews found many typographical
errors; T. Taft (USA), who always seemed to have a suggestion when we were
stuck, and who also was usually able to provide the valuable service of
explaining why things were as they are; S. Baird (USA), who found many obscure
problems with the proposals; and A. Burns (UK), who pushed many of the
real-time proposals to completion. Other ARG members who contributed were: R.
Dewar (USA), G. Dismukes (USA), R. Duff (USA), K. Ishihata (Japan), S. Michell
(Canada), E. Ploedereder (Germany), J.P. Rosen (France), E. Schonberg (USA),
J. Tokar (USA), and T. Vardanega (Italy).

71.6/2 Special thanks go to Ada-Europe and the Ada Resource Association,
without whose help and support the Amendment and this consolidated reference
manual would not have been possible. M. Heaney (USA) requires special thanks
for his tireless work on the containers packages. Finally, special thanks go
to the convener of ISO/IEC JTC 1/SC 22/WG 9, J. Moore (USA), who guided the
document through the standardization process.



Changes

72  The International Standard is the same as this version of the Reference
Manual, except:

73    * This list of Changes is not included in the International Standard.

74    * The "Acknowledgements" page is not included in the International
        Standard.

75    * The text in the running headers and footers on each page is slightly
        different in the International Standard.

76    * The title page(s) are different in the International Standard.

77    * This document is formatted for 8.5-by-11-inch paper, whereas the
        International Standard is formatted for A4 paper (210-by-297mm); thus,
        the page breaks are in different places.

77.1/1   * The "Foreword to this version of the Ada Reference Manual" clause
        is not included in the International Standard.

77.2/2   * The "Using this version of the Ada Reference Manual" clause is not
        included in the International Standard.

Using this version of the Ada Reference Manual

77.3/2 This document has been revised with the corrections specified in
Technical Corrigendum 1 (ISO/IEC 8652:1995/COR.1:2001) and Amendment 1
(ISO/IEC 8652/AMD.1:2007). In addition, a variety of editorial errors have
been corrected.

77.4/2 Changes to the original 8652:1995 can be identified by the version
number following the paragraph number. Paragraphs with a version number of /1
were changed by Technical Corrigendum 1 or were editorial corrections at that
time, while paragraphs with a version number of /2 were changed by Amendment 1
or were more recent editorial corrections. Paragraphs not so marked are
unchanged by Amendment 1, Technical Corrigendum 1, or editorial corrections.
Paragraph numbers of unchanged paragraphs are the same as in the original Ada
Reference Manual. In addition, some versions of this document include revision
bars near the paragraph numbers. Where paragraphs are inserted, the paragraph
numbers are of the form pp.nn, where pp is the number of the preceding
paragraph, and nn is an insertion number. For instance, the first paragraph
inserted after paragraph 8 is numbered 8.1, the second paragraph inserted is
numbered 8.2, and so on. Deleted paragraphs are indicated by the text This
paragraph was deleted. Deleted paragraphs include empty paragraphs that were
numbered in the original Ada Reference Manual.

